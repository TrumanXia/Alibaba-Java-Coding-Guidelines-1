# 异常处理

1. **[强制]** Java 类库中定义的可以通过预检查方式规避的 `RuntimeException` 异常不应该通过 `catch` 的方式来处理, 比如: `NullPointerException`, `IndexOutOfBoundsException` 等等;

    <span style="color:orange">说明</span>: 无法通过预检查的异常除外, 比如, 在解析字符串形式的数字时, 不得不通过 `catch NumberFormatException` 来实现;

    <span style="color:green">正例</span>:

    ```java
    if (obj !=  `null` ) {...}
    ```

    <span style="color:red">反例</span>:

    ```java
    try { obj.method() } catch (NullPointerException e) {…}
    ```

1. **[强制]** 异常不要用来做流程控制, 条件控制;

    <span style="color:orange">说明</span>: 异常设计的初衷是解决程序运行中的各种意外情况, 且异常的处理效率比条件判断方式要低很多;

1. **[强制]** `catch` 时请分清稳定代码和非稳定代码, 稳定代码指的是无论如何不会出错的代码; 对于非稳定代码的 `catch` 尽可能进行区分异常类型, 再做对应的异常处理;

    <span style="color:orange">说明</span>: 对大段代码进行 `try-catch`, 使程序无法根据不同的异常做出正确的应激反应, 也不利于定位问题, 这是一种不负责任的表现;

    <span style="color:green">正例</span>: 用户注册的场景中, 如果用户输入非法字符, 或用户名称已存在, 或用户输入密码过于简单, 在程序上作出分门别类的判断, 并提示给用户;

1. **[强制]** 捕获异常是为了处理它, 不要捕获了却什么都不处理而抛弃之, 如果不想处理它, 请将该异常抛给它的调用者; 最外层的业务使用者, 必须处理异常, 将其转化为用户可以理解的内容;

1. **[强制]** 有 `try` 块放到了事务代码中, `catch` 异常后, 如果需要回滚事务, 一定要注意手动回滚事务;

1. **[强制]** `finally` 块必须对资源对象, 流对象进行关闭, 有异常也要做 `try-catch`;

    <span style="color:orange">说明</span>: 如果 JDK 7 及以上, 可以使用 `try-with-resources` 方式;

1. **[强制]** 不要在 `finally` 块中使用 `return`;

    <span style="color:orange">说明</span>: `finally` 块中的 `return` 返回后方法结束执行, 不会再执行 `try` 块中的 `return` 语句;

1. **[强制]** 捕获异常与抛异常, 必须是完全匹配, 或者捕获异常是抛异常的父类;

    <span style="color:orange">说明</span>: 如果预期对方抛的是绣球, 实际接到的是铅球, 就会产生意外情况;

1. **[推荐]** 方法的返回值可以为 `null` , 不强制返回空集合, 或者空对象等, 必须添加注释充分

    <span style="color:orange">说明</span>什么情况下会返回 `null` 值;  <span style="color:orange">说明</span>: 本手册明确防止 `NPE` 是调用者的责任; 即使被调用方法返回空集合或者空对象, 对调用者来说, 也并非高枕无忧, 必须考虑到远程调用失败, 序列化失败, 运行时异常等场景返回 `null` 的情况;

1. **[推荐]** 防止 `NPE` , 是程序员的基本修养, 注意 `NPE` 产生的场景:

    1. 返回类型为基本数据类型, `return` 包装数据类型的对象时, 自动拆箱有可能产生 `NPE` ;

        <span style="color:red">反例</span>: `public int f() { return Integer对象}`, 如果为 `null`, 自动解箱抛 `NPE`;

    1. 数据库的查询结果可能为 `null` ;

    1. 集合里的元素即使 `isNotEmpty`, 取出的数据元素也可能为 `null`;

    1. 远程调用返回对象时, 一律要求进行空指针判断, 防止 `NPE`;

    1. 对于 `Session` 中获取的数据, 建议`NPE`检查, 避免空指针;

    1. 级联调用 `obj.getA().getB().getC()`；一连串调用, 易产生 `NPE`;

    <span style="color:green">正例</span>: 使用 JDK 8 的 `Optional` 类来防止 `NPE` 问题;

1. **[推荐]** 定义时区分 `unchecked`/`checked` 异常, 避免直接抛出 `new RuntimeException()`, 更不允许抛出 `Exception` 或者 `Throwable`, 应使用有业务含义的自定义异常; 推荐业界已定义过的自定义异常, 如: `DAOException`/`ServiceException` 等;

1. **[参考]** 对于公司外的 `http`/`api` 开放接口必须使用 "错误码" ；而应用内部推荐异常抛出；跨应用间 `RPC` 调用优先考虑使用 `Result` 方式, 封装 `isSuccess()` 方法,  "错误码",  "错误简短信息" ;

    <span style="color:orange">说明</span>: 关于 `RPC` 方法返回方式使用 `Result` 方式的理由:

    1. 使用抛异常返回方式, 调用方如果没有捕获到就会产生运行时错误;

    1. 如果不加栈信息, 只是 `new` 自定义异常, 加入自己的理解的 `error message`, 对于调用端解决问题的帮助不会太多; 如果加了栈信息, 在频繁调用出错的情况下, 数据序列化和传输的性能损耗也是问题;

1. **[参考]** 避免出现重复的代码 (`Don’t Repeat Yourself`) , 即 `DRY` 原则;

    <span style="color:orange">说明</span>: 随意复制和粘贴代码, 必然会导致代码的重复, 在以后需要修改时, 需要修改所有的副本, 容易遗漏; 必要时抽取共性方法, 或者抽象公共类, 甚至是组件化;

    <span style="color:green">正例</span>: 一个类中有多个 `public` 方法, 都需要进行数行相同的参数校验操作, 这个时候请抽取:

    ```java
    private boolean checkParam(DTO dto) {...}
    ```
